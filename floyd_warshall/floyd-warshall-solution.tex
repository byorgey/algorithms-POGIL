% -*- compile-command: "pdflatex --enable-write18 XXX.tex" -*-
\documentclass{tufte-handout}

\usepackage{algo-activity}
\usepackage{xcolor}

\title{Algorithms: Floyd-Warshall}
\date{}

\begin{document}

\maketitle

\begin{questions}

\item Consider the \emph{adjacency matrix} in Model \ref{adj_matrix}. (In an adjacency matrix for a directed graph, each entry is the weight of an edge in the graph.) Nodes on the left are originating vertices. Nodes on the top are destination vertices.

\begin{objective}
  Students will derive an efficient algorithm for finding the shortest paths between all pairs of vertices in a directed, weighted graph.
\end{objective}

The table below lists each pair of vertices and the weight of the edge from the first vertex to the second. It then lists the possible intermediate vertices. Find the distance for each path. Then write the minimum distance in the final column. The first row is completed for you as an example.\label{by_hand}
\\
{\color{red} 
\begin{tabular}{|c|c|c|c|c|c|c|c|c|}
\hline
Pair & $w_{v_i v_j}$ & $x_1$ & $x_2$ & $v_i$ $x_1$ $v_j$ & $v_i$ $x_2$ $v_j$ &$v_i$ $x_1$ $x_2$ $v_j$ &$v_i$ $x_2$ $x_1$ $v_j$ & Minimum\\
\hline
$v_1$ $v_2$ & 8 & $v_3$ & $v_4$ & 10 & 3 & 10 & 10 & 3 \\
$v_2$ $v_1$ & 3 & $v_3$ & $v_4$ & 11 & 12 & 11 & 19 & 3 \\
$v_1$ $v_3$ & 7 & $v_2$ & $v_4$ & 11 & 7 & 19 & 6 & 6 \\ 
$v_3$ $v_1$ & 8 & $v_2$ & $v_4$ & 6 & 8 & 15 & 6 & 6 \\ 
$v_1$ $v_4$ & 2 & $v_2$ & $v_3$ & 14 & 9 & 13 & 16 & 2\\ 
$v_4$ $v_1$ & 6 & $v_2$ & $v_3$ & 4 & 13 & 12 & 11 & 4\\ 
$v_2$ $v_3$ & 3 & $v_1$ & $v_4$ & 10 & 11 & 10 & 19 & 3\\ 
$v_3$ $v_2$ & 3 & $v_1$ & $v_4$ & 16 & 3 & 11 & 16 & 3\\ 
$v_2$ $v_4$ & 6 & $v_1$ & $v_3$ & 5 & 5 & 12 & 13 & 5 \\ 
$v_4$ $v_2$ & 1 & $v_1$ & $v_3$ & 14 & 8 & 16 & 21 & 1\\
$v_3$ $v_4$ & 2 & $v_1$ & $v_2$ & 10 & 9 & 22 & 8 & 2\\
$v_4$ $v_3$ & 5 & $v_1$ & $v_2$ & 13 & 4 & 17 & 11 & 4\\
\hline
\end{tabular}
}

\begin{model}{Adjacency Matrix}{adj_matrix}
\begin{tabular}{ l r r r r }
      & $v_1$ & $v_2$ & $v_3$ & $v_4$ \\
$v_1$ &       & 8     & 7     & 2 \\
$v_2$ & 3     &       & 3     & 6 \\
$v_3$ & 8     & 3     &       & 2 \\
$v_4$ & 6     & 1     & 5     &   \\
\end{tabular}
\label{adj_matrix}
\end{model}

\item Inspired by your answers to Question \ref{adj_matrix}, fill in the base case and recursive cases of the algorithm below to find the shortest path distance between any pairs of vertices for a graph with $n$ vertices. \label{f-w-1}
{\color{red}
\begin{verbatim}
shortest_path_distance(g, start, end, k)
  if k == 0
    return (edge weight in g from start to end)
  else 
    return min(shortest_path_distance(g, start , end , k - 1),
               shortest_path_distance(g, start, k, k - 1) 
               + shortest_path_distance(g, k, end, k - 1))
\end{verbatim}
}

\item To prove the algorithm from Question \ref{f-w-1} correctly finds the shortest path from \verb|start| to \verb|end|, we need to use \emph{strong induction}. What would the base cases be for a correctness proof by strong induction?  {\color{red} For every pair of vertices, we return the weight of the edge between them.}

\item How many base cases would there be?  {\color{red} There will be $n^2$ base cases, as we need a base case for every possible edge.}

\item What would be the inductive hypothesis? {\color{red} 
For any pair of vertices \verb|start| and \verb|end|, and any $i \le k - 1$, \verb|shortest_path_distance(g, start, end, k - 1)| returns the distance of the shortest path from \verb|start| to \verb|end|.}

\item What would we need to prove in the inductive step?

{\color{red} 
For any pair of vertices \verb|start| and \verb|end|, \verb|shortest_path_distance(g, start, end, k)| returns the distance of the shortest path from \verb|start| to \verb|end|.}

\item Complete the proof by strong induction that this algorithm finds the shortest path from \verb|start| to \verb|end|.

{\color{red} We know \verb|shortest_path_distance(g, start, end, k - 1)| is the shortest path if we exclude vertex $k$ by the inductive hypothesis. If we include vertex $k$, the shortest path distance is the sum of distances between \verb|start| and $k$ and $k$ and \verb|end|, as those recursively generated distances are also the shortest by the inductive hypothesis. Therefore, whichever of the two is lower is the shortest distance, which is what we return.
}

\item Write a recurrence for the asymptotic time complexity of the algorithm you wrote in Question \ref{f-w-1}. \label{recurrence}

{\color{red} \[T(k) = 3T(k-1) + O(1) \]}

\item Estimate the asymptotic time complexity of your algorithm based on the recurrence from Question \ref{recurrence}.

{\color{red} $O(3^n)$}

\item If an edge is missing between two vertices, how might the algorithm (or adjacency matrix) from Question \ref{f-w-1} be modified to handle this?

{\color{red} Give it an infinite weight. It will then always be safely ignored by the min() function.}

\item If we were to rewrite the algorithm from Question \ref{f-w-1} as a bottom-up dynamic programming algorithm, how many dimensions would the table need to have? What would each dimension represent?

{\color{red} It would need two dimensions. The first dimension is the originating vertex and the second dimension is the destination vertex. Each entry is the shortest known distance between them.}

\item Write pseudocode for a bottom-up dynamic programming version of the algorithm. (This is known as the Floyd-Warshall algorithm.) \label{f-w-2}

{\color{red}
\begin{verbatim}
floyd_warshall(g)
  for i in g.vertices
    for j in g.vertices
      table[i][j] = g.edge(i, j)
  for k in g.vertices
    alternative = table[i][k] + table[k][j]
    if alternative < table[i][j]
      table[i][j] = alternative
  return table
\end{verbatim}
}

\item What is the asymptotic time complexity of the algorithm from Question \ref{f-w-2}?

{\color{red} $O(n^3)$}

\item How might we augment the dynamic programming table so that we can reconstruct the path between two vertices?

{\color{red} For the entry for $(i, j)$, have an additional field indicating the next vertex to visit as part of the shortest path to get there. Initialize this to $j$ at the start. Update it to $k$ whenever we update \verb|table[i][j]|.}

\item Under what circumstances is Dijkstra's algorithm preferable to the Floyd-Warshall algorithm? Why?

{\color{red} If you only care about one pair of vertices, Dijkstra's is a lot more efficient.}

\item Under what circumstances is the Floyd-Warshall algorithm preferable to Dijkstra's algorithm? Why?

{\color{red} If you want lots of shortest-paths in a dense graph where $E$ is close to $V^2$, it is more efficient to do $O(V^3)$ work once rather than $O(V^2 log V) * V = O(V^3 log V)$.}
\end{questions}

\end{document}
